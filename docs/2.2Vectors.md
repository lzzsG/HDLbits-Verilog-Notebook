---
layout: page
title: 2.2 Vectors 向量
permalink: /VerilogLanguage/Vectors
nav_order: 4
description: "2.2 Verilog Language Vectors 向量"


---

# Verilog Language: Vectors

- [Vectors](https://hdlbits.01xz.net/wiki/vector0) **向量**
- [Vectors in more detail](https://hdlbits.01xz.net/wiki/vector1) **详细解释向量**
- [Vector part select](https://hdlbits.01xz.net/wiki/vector2) **向量部分选择**
- [Bitwise operators](https://hdlbits.01xz.net/wiki/vectorgates) **按位操作符**
- [Four-input gates](https://hdlbits.01xz.net/wiki/gates4) **四输入门电路**
- [Vector concatenation operator](https://hdlbits.01xz.net/wiki/vector3) **向量连接操作符**
- [Vector reversal 1](https://hdlbits.01xz.net/wiki/vectorr) **向量翻转 1**
- [Replication operator](https://hdlbits.01xz.net/wiki/vector4) **复制操作符**
- [More replication](https://hdlbits.01xz.net/wiki/vector5) **更多复制**

---

# Vector

在数字电路中，**向量（vectors）** 是一种非常有用的工具，用来将一组相关的信号通过一个名字组合在一起，便于处理和管理。例如，`wire [7:0] w;` 声明了一个 8 位宽度的向量 `w`，这相当于声明了 8 条独立的导线（wire）。通过使用向量，设计师可以更方便地操作多个位宽信号。

### 向量的声明和使用

在 Verilog 中，声明向量时，位宽信息（位数范围）放在向量名称的前面。这与 C 语言中的语法有所不同。此外，当需要选择特定位时，位置信息放在向量名的后面。例如：

```verilog
wire [99:0] my_vector;      // 声明一个 100 位的向量
assign out = my_vector[10]; // 从向量中选择第 10 位并赋值给 out
```

在本练习中，要求你构建一个电路，它接收一个 3 位宽的输入向量，并将其直接输出。同时，还需要将输入向量的每一位拆分为 3 个独立的 1 位输出信号。

<img src="{{ site.baseurl }}/docs/assets/userlmn_93094693bcf49051006037d40c75f4d6.png" alt="img" style="zoom:50%;" />

### 任务描述

你需要实现一个模块，该模块包含以下功能：

- 一个 3 位宽的输入向量 `vec`。
- 一个 3 位宽的输出向量 `outv`，它是 `vec` 的复制。
- 三个独立的 1 位输出 `o2`, `o1`, `o0`，分别对应 `vec` 中的 2 位、1 位和 0 位。

<img src="{{ site.baseurl }}/docs/assets/QQ_1729498220094.png" alt="QQ_1729498220094" style="zoom:50%;" />

### Verilog 代码实现

你可以通过向量操作直接复制整个向量，同时使用 **位选择** 来访问向量的特定位并连接到独立的 1 位输出信号。

**完整的 Verilog 代码：**

```verilog
module top_module ( 
    input wire [2:0] vec,     // 输入 3 位向量
    output wire [2:0] outv,   // 输出 3 位向量
    output wire o2,           // 输出信号 o2，连接 vec[2]
    output wire o1,           // 输出信号 o1，连接 vec[1]
    output wire o0            // 输出信号 o0，连接 vec[0]
); 

    // 复制整个输入向量到输出向量
    assign outv = vec;

    // 分别连接向量的各个位到独立的 1 位输出
    assign o2 = vec[2];
    assign o1 = vec[1];
    assign o0 = vec[0];

endmodule
```

### 代码讲解

1. **输入和输出端口声明**：
   - `input wire [2:0] vec`：声明一个 3 位宽的输入向量 `vec`。这意味着输入信号由 3 位组成。
   - `output wire [2:0] outv`：声明一个 3 位宽的输出向量 `outv`，它将与输入 `vec` 相同。
   - `output wire o2, o1, o0`：声明 3 个独立的 1 位输出信号，分别对应输入向量 `vec` 的 2 位、1 位和 0 位。

2. **向量复制**：
   - `assign outv = vec;`：将输入向量 `vec` 的值直接复制给输出向量 `outv`。这一步操作会将 `vec` 的所有 3 位传递给 `outv`，使两者相等。

3. **位选择**：
   - `assign o2 = vec[2];`：从 `vec` 向量中选择第 2 位，并将其赋值给输出信号 `o2`。
   - `assign o1 = vec[1];`：从 `vec` 向量中选择第 1 位，并将其赋值给输出信号 `o1`。
   - `assign o0 = vec[0];`：从 `vec` 向量中选择第 0 位，并将其赋值给输出信号 `o0`。

### 关键概念

1. **向量声明**：  
   在 Verilog 中，向量声明通过 `[位宽:0]` 的方式进行。`wire [2:0] vec;` 声明了一个 3 位宽度的向量，从第 2 位到第 0 位。
2. **位选择（Part Select）**：  
   使用 `vec[2]` 可以从向量 `vec` 中选择第 2 位。这是一种常用的操作，可以方便地从多位信号中提取单个位。

---

# Vectors in more detail

在硬件描述语言（如Verilog）中，向量（vector）用于将相关的信号组合在一起，用一个名字表示，从而更方便地进行操作。例如，`wire [7:0] w;` 声明了一个8位的向量 `w`，这相当于定义了8条独立的线。向量的使用可以极大简化信号的管理和操作，特别是在处理多位信号时。

### 1 声明向量

向量的声明格式如下：

```
type [upper:lower] vector_name;
```

其中，`type` 指定向量的数据类型，通常为 `wire` 或 `reg`。如果声明的是输入或输出端口，`type` 还可以包括端口类型（例如 `input` 或 `output`）。以下是一些常见的例子：

- `wire [7:0] w;`  // 8位的 `wire`
- `reg  [4:1] x;`  // 4位的 `reg`
- `output reg [0:0] y;`  // 1位的 `reg`，同时也是一个输出端口（这仍然是一个向量）
- `input wire [3:-2] z;`  // 6位的 `wire` 输入（允许使用负数范围）
- `output [3:0] a;`  // 4位的输出 `wire`。类型为 `wire`，除非另行指定
- `wire [0:7] b;`  // 8位的 `wire`，其中 `b[0]` 是最高有效位（MSB）

向量的字节序（endianness）决定了最低有效位（LSB）是位于较低索引（如小端格式 `[3:0]`）还是较高索引（如大端格式 `[0:3]`）。在 Verilog 中，一旦一个向量被声明为特定的字节序，它必须始终以相同的方式使用。例如，如果向量 `vec` 被声明为 `wire [3:0] vec;`，那么尝试使用 `vec[0:3]` 是不合法的。保持字节序的一致性是一个好的编程习惯，否则当不同字节序的向量一起使用或赋值时，容易产生奇怪的 bug。

### 1.1 隐式网（Implicit Nets）

隐式网（implicit nets）是 Verilog 中常见的导致难以检测 bug 的原因。在 Verilog 中，网类型信号（net-type signals）可以通过 `assign` 语句隐式创建，或者通过未声明的信号连接到模块端口。这种隐式网总是 1 位宽的 `wire`，如果你原本打算使用向量，这就会导致 bug。通过使用 `default_nettype none` 指令，可以禁用隐式网的创建。

示例代码：

```verilog
wire [2:0] a, c;   // 声明两个向量
assign a = 3'b101;  // a = 101
assign b = a;       // b 被隐式创建为 1 位宽的 `wire`
assign c = b;       // c = 001  <-- 这里产生了 bug
my_module i1 (d,e); // d 和 e 会隐式被声明为 1 位宽的信号，如果未显式声明为向量，这可能会导致 bug。
```

通过添加 `default_nettype none`，上述代码中的第二行将产生一个错误，从而使问题更加明显。

### 1.2 非打包数组与打包数组（Unpacked vs. Packed Arrays）

你可能已经注意到，在声明向量时，索引位于向量名之前。这是在声明打包维度（packed dimensions），即位被“打包”在一起（在仿真器中相关，在硬件中不显著）。而非打包维度（unpacked dimensions）则声明在向量名之后，通常用于声明内存数组。在此课程中，我们没有使用非打包数组，因为我们没有覆盖内存数组的内容。以下是一个例子：

```verilog
reg [7:0] mem [255:0];   // 256 个非打包元素，每个元素是一个 8 位的打包 `reg` 向量。
reg mem2 [28:0];         // 29 个非打包元素，每个元素是一个 1 位的 `reg`。
```

### 2 访问向量元素：部分选择（Part-Select）

访问整个向量可以直接使用向量名称，例如：

```verilog
assign w = a;
```

此操作将整个 4 位的向量 `a` 赋值给整个 8 位的向量 `w`（上面的声明）。如果左右两侧的位宽不匹配，Verilog 会根据需要进行零扩展或截断。

我们还可以使用部分选择运算符来访问向量的一部分：

```verilog
w[3:0]      // 只访问 w 的低 4 位
x[1]        // 访问 x 的最低位
x[1:1]      // 也是访问 x 的最低位
z[-1:-2]    // 访问 z 的最低两位
b[3:0]      // 非法操作。向量部分选择必须匹配声明的方向。
b[0:3]      // 访问 b 的最高 4 位。
```

例如，以下代码将 `b` 的高 4 位赋值给 `w` 的低 4 位：

```verilog
assign w[3:0] = b[0:3];  // w[3] = b[0], w[2] = b[1], 等等。
```

<img src="{{ site.baseurl }}/docs/assets/QQ_1729498433002.png" alt="QQ_1729498433002" style="zoom:50%;" />

### Verilog 代码

在本设计中，我们需要一个 16 位的输入向量 `in`，并将其拆分为两个 8 位输出信号：`out_hi`（高 8 位）和 `out_lo`（低 8 位）。

```verilog
`default_nettype none     // 禁用隐式网络声明，减少某些类型的错误
module top_module( 
    input wire [15:0] in,      // 16 位输入向量
    output wire [7:0] out_hi,  // 高 8 位输出
    output wire [7:0] out_lo   // 低 8 位输出
);

    // 将输入信号的高 8 位赋值给输出 out_hi
    assign out_hi = in[15:8];
    
    // 将输入信号的低 8 位赋值给输出 out_lo
    assign out_lo = in[7:0];

endmodule
```

### 代码讲解

1. **输入和输出端口声明：**
   - `input wire [15:0] in`：声明一个 16 位宽的输入信号 `in`。这个信号包括 16 位，可以使用位选择操作来访问其高位和低位。
   - `output wire [7:0] out_hi` 和 `output wire [7:0] out_lo`：分别声明两个 8 位宽的输出信号，用来接收输入信号的高 8 位和低 8 位。

2. **位选择操作：**
   - `assign out_hi = in[15:8];`：从输入向量 `in` 中选择高 8 位（`in[15:8]`），并将其赋值给 `out_hi`。
   - `assign out_lo = in[7:0];`：从输入向量 `in` 中选择低 8 位（`in[7:0]`），并将其赋值给 `out_lo`。

### 关键概念

- **向量声明**：`wire [15:0] in;` 表示声明一个 16 位宽的输入向量，能够传输 16 个相关的信号。
- **位选择**：通过 `in[15:8]` 和 `in[7:0]` 可以从输入向量中提取不同的部分，这些部分可以直接分配给输出信号。

---

# Vector Part Select

在这个任务中，您需要设计一个电路，该电路将 32 位输入向量按字节顺序进行反转。这种操作在处理**大小端（endianness）**时非常常见，比如将小端（little-endian）格式转换为大端（big-endian）格式，反之亦然。大小端问题在跨平台的数据传输中非常重要，尤其是在不同架构和网络协议之间交换数据时。

### 任务描述

- 输入信号 `in` 是一个 32 位向量，可以被视为 4 个字节（每个字节 8 位）。
- 输出信号 `out` 也是 32 位宽。
- 你需要将输入信号 `in` 中的字节顺序进行反转：
  - `in[31:24]` -> `out[7:0]`
  - `in[23:16]` -> `out[15:8]`
  - `in[15:8]` -> `out[23:16]`
  - `in[7:0]` -> `out[31:24]`

![QQ_1729498653935]({{ site.baseurl }}/docs/assets/QQ_1729498653935.png)

### Verilog 代码实现

可以使用位选择（part-select）操作将输入向量中的各个字节重新排列到输出向量中。以下是实现代码：

```verilog
module top_module( 
    input [31:0] in,        // 32 位输入信号
    output [31:0] out       // 32 位输出信号
);

    // 将输入信号中的每个字节重新排列到输出信号中
    assign out[31:24] = in[7:0];     // 将输入的最低字节放到输出的最高字节
    assign out[23:16] = in[15:8];    // 第二个字节
    assign out[15:8] = in[23:16];    // 第三个字节
    assign out[7:0] = in[31:24];     // 将输入的最高字节放到输出的最低字节

endmodule
```

### 代码讲解

1. **输入和输出端口声明：**
   - `input [31:0] in`：声明 32 位宽的输入信号 `in`，表示一个包含 4 个字节的数据。
   - `output [31:0] out`：声明 32 位宽的输出信号 `out`，将存储反转后的字节顺序。

2. **位选择操作：**
   - `assign out[31:24] = in[7:0];`：将输入信号 `in` 的最低字节（`in[7:0]`）赋值给输出的最高字节位置（`out[31:24]`）。
   - `assign out[23:16] = in[15:8];`：将输入信号 `in` 的第二个字节赋值给输出的第二高字节位置。
   - `assign out[15:8] = in[23:16];`：将输入信号 `in` 的第三个字节赋值给输出的第三高字节位置。
   - `assign out[7:0] = in[31:24];`：将输入信号 `in` 的最高字节赋值给输出的最低字节位置。

### 关键概念

1. **位选择（Part-Select）：**  
   通过 `in[31:24]` 等位选择操作，可以选择输入信号的特定位来进行操作。通过这种方法，能轻松对信号的各个字节进行重新排序。

2. **大小端转换（Endianness Conversion）：**  
   这种操作通常用于在不同架构（如 x86 的小端和网络协议中的大端格式）之间进行数据格式的转换。

---

# Bitwise Operators

在该电路中，有两个3位输入向量，电路需要计算这两个向量的逐位（bitwise）或运算、逻辑或运算，以及这两个向量的反（NOT）运算。具体来说，将 `b` 的反转结果放在 `out_not` 的高位部分（位[5:3]），而将 `a` 的反转结果放在 `out_not` 的低位部分。

### 逐位运算 vs 逻辑运算

在处理布尔运算符时，需要区分逐位（bitwise）运算和逻辑（logical）运算。对于向量操作，这种区分尤为重要：

- **逐位运算**：对两个 N 位向量的每一位分别进行布尔操作，最终产生一个 N 位的输出。例如，逐位或运算（bitwise-OR）对向量中的每一位分别执行或运算，输出同样是 N 位的结果。
  
  对于两个3位的向量 `a` 和 `b`，逐位或运算表示为：

  ```
  a = 3'b101;  // 例子中的 a
  b = 3'b011;  // 例子中的 b
  a | b = 3'b111;  // 每个位进行或运算
  ```

- **逻辑运算**：逻辑运算将整个向量视为一个布尔值。非零向量表示 `true`，零向量表示 `false`，逻辑或运算（logical-OR）将生成一个 1 位的输出结果。
  
  对于向量 `a` 和 `b` 的逻辑或运算：

  ```
  a = 3'b101;  // 非零，表示为 true
  b = 3'b011;  // 非零，表示为 true
  a || b = 1'b1;  // 逻辑或运算的结果是1（true）
  ```

### 电路设计说明

1. **逐位或运算（bitwise-OR）**：计算 `a` 和 `b` 的逐位或运算，并输出3位结果。每一位的运算都是独立的。

2. **逻辑或运算（logical-OR）**：将 `a` 和 `b` 作为整体进行逻辑或运算，输出结果为 1 位，即如果两个向量中至少有一个非零，结果为 `1`，否则为 `0`。

3. **反运算（NOT）**：对向量 `a` 和 `b` 进行逐位反运算。将 `b` 的反转结果放入 `out_not` 的高位部分（位[5:3]），将 `a` 的反转结果放入低位部分（位[2:0]）。

### 任务描述

1. **输入：** 两个 3 位的输入向量 `a` 和 `b`。
2. **输出：**
   - `out_or_bitwise`：`a` 和 `b` 的按位 OR 结果，3 位宽。
   - `out_or_logical`：`a` 和 `b` 的逻辑 OR 结果，1 位宽。
   - `out_not`：`b` 的反相结果放在高 3 位，`a` 的反相结果放在低 3 位，6 位宽。

<img src="{{ site.baseurl }}/docs/assets/QQ_1729498885986.png" alt="QQ_1729498885986" style="zoom:50%;" />

### Verilog 代码实现

下面是基于上述描述的 Verilog 实现：

```verilog
module top_module( 
    input [2:0] a,              // 输入向量 a
    input [2:0] b,              // 输入向量 b
    output [2:0] out_or_bitwise, // 输出：按位 OR 的结果
    output out_or_logical,       // 输出：逻辑 OR 的结果
    output [5:0] out_not         // 输出：按位 NOT 的结果
);

    // 计算按位 OR（逐位对 a 和 b 进行 OR 操作）
    assign out_or_bitwise = a | b;

    // 计算逻辑 OR（将 a 和 b 看作布尔值进行 OR 操作）
    assign out_or_logical = (a || b);

    // 计算按位 NOT，b 的反相放在高位，a 的反相放在低位
    assign out_not[5:3] = ~b;   // b 的反相
    assign out_not[2:0] = ~a;   // a 的反相

endmodule
```

### 代码讲解

1. **输入和输出端口声明**：
   - `input [2:0] a, b`：两个 3 位的输入向量。
   - `output [2:0] out_or_bitwise`：存储按位 OR 的 3 位结果。
   - `output out_or_logical`：存储逻辑 OR 的 1 位结果。
   - `output [5:0] out_not`：存储两个向量的反相结果，6 位宽。

2. **按位 OR**：
   - `assign out_or_bitwise = a | b;`：使用按位 OR 运算符 `|` 对 `a` 和 `b` 进行逐位 OR 操作，输出也是 3 位宽的向量。

3. **逻辑 OR**：
   - `assign out_or_logical = (a || b);`：使用逻辑 OR 运算符 `||`，将 `a` 和 `b` 看作布尔值进行 OR 操作。任何一位为 1，结果即为 `1`，否则为 `0`。

4. **按位 NOT**：
   - `assign out_not[5:3] = ~b;`：反相 `b`，并将结果存储在 `out_not` 的高 3 位。
   - `assign out_not[2:0] = ~a;`：反相 `a`，并将结果存储在 `out_not` 的低 3 位。

---

# Four-Input Gates

这个任务是构建一个具有四个输入（`in[3:0]`）的组合逻辑电路，该电路具有三个输出，每个输出分别对应于不同的逻辑运算操作：4输入与（AND）、4输入或（OR）、以及4输入异或（XOR）。

### 输出描述

1. **out_and**：这是一个4输入AND门的输出。它计算输入向量 `in[3:0]` 的每个位的 **与** 运算（即所有输入都为1时，输出为1；否则为0）。

   公式：  

   ```verilog
   out_and = in[3] & in[2] & in[1] & in[0];
   ```

2. **out_or**：这是一个4输入OR门的输出。它计算输入向量 `in[3:0]` 的每个位的 **或** 运算（即只要有一个输入为1，输出就是1；所有输入都为0时，输出才为0）。

   公式：  

   ```verilog
   out_or = in[3] | in[2] | in[1] | in[0];
   ```

3. **out_xor**：这是一个4输入XOR门的输出。它计算输入向量 `in[3:0]` 的每个位的 **异或** 运算（即输入的1的个数为奇数时输出为1，个数为偶数时输出为0）。

   公式：  

   ```verilog
   out_xor = in[3] ^ in[2] ^ in[1] ^ in[0];
   ```

<img src="{{ site.baseurl }}/docs/assets/QQ_1729499096419.png" alt="QQ_1729499096419" style="zoom:50%;" />

### 模块声明

在 Verilog 中，可以使用以下代码声明并实现这个组合电路模块：

```verilog
module top_module( 
    input [3:0] in,       // 4位输入信号
    output out_and,       // 4输入AND门的输出
    output out_or,        // 4输入OR门的输出
    output out_xor        // 4输入XOR门的输出
);

    // 使用逻辑运算符实现与、或、异或操作
    assign out_and = in[3] & in[2] & in[1] & in[0];  // 与操作
    assign out_or = in[3] | in[2] | in[1] | in[0];   // 或操作
    assign out_xor = in[3] ^ in[2] ^ in[1] ^ in[0];  // 异或操作

endmodule
```

### 逻辑运算回顾

- **AND门（与门）**：当所有输入为1时，输出才为1，否则为0。  
- **OR门（或门）**：只要有一个输入为1，输出就为1，所有输入为0时，输出才为0。  
- **XOR门（异或门）**：当输入中1的数量为奇数时，输出为1，否则为0。

### 电路功能

该电路接收4位输入，并对这些输入执行三种不同的逻辑运算操作。`out_and` 表示所有输入同时为1的情况，`out_or` 表示至少有一个输入为1的情况，`out_xor` 表示输入位中1的个数为奇数的情况。这些逻辑操作在数字电路设计中非常常见，例如用于条件判断、错误检测等。

---

# Vector Concatenation Operator

向量的部分选择用于从向量中选择一部分信号，而连接运算符 `{a, b, c}` 用于将多个较小的向量拼接在一起，形成一个更大的向量。这个运算符非常有用，特别是在需要组合多个向量或者重新组织信号时。

### 连接运算符的使用

连接运算符 `{}` 可以将多个向量按顺序拼接，形成一个更长的向量。例如：

```verilog
{3'b111, 3'b000} => 6'b111000
{1'b1, 1'b0, 3'b101} => 5'b10101
{4'ha, 4'd10} => 8'b10101010  // 4'ha 和 4'd10 都是 4'b1010
```

这里的连接操作将每个较小的部分按给定的顺序拼接成一个更大的二进制数。例如：

- `3'b111` 和 `3'b000` 被连接成 `6'b111000`。
- `1'b1, 1'b0, 3'b101` 形成一个 5 位的结果：`5'b10101`。
- `4'ha`（即十六进制A，对应二进制 `1010`）和 `4'd10`（即十进制10，对应二进制 `1010`）拼接成一个8位的向量 `8'b10101010`。

### 连接操作中的位宽要求

连接运算需要知道每个组成部分的位宽，因为这直接影响拼接后的总位宽。如果某个部分的位宽没有明确指定，Verilog 会报错。如下所示，`{1, 2, 3}` 是非法的，因为常量 `1`、`2` 和 `3` 的位宽没有定义，这会导致错误：**unsized constants are not allowed in concatenations**。

为了避免这种错误，常量必须明确声明为具有特定的位宽。例如：

```verilog
{1'b1, 2'b10, 3'b011}  // 这是合法的，位宽明确
```

### 连接运算符在赋值中的应用

连接运算符可以用于赋值操作的左右两侧。例如：

```verilog
input [15:0] in;
output [23:0] out;
assign {out[7:0], out[15:8]} = in;  // 交换两个字节，左侧和右侧都是16位向量
assign out[15:0] = {in[7:0], in[15:8]};  // 同样的操作
assign out = {in[7:0], in[15:8]};  // 这有所不同，右侧的16位向量扩展为24位
                                   // 左侧的out[23:16] 被扩展为零
```

在第一个例子中，我们交换了 `out` 的两个字节，但没有改变 `out[23:16]`。而在第三个例子中，由于 `out` 是24位的，而右侧是16位的，Verilog 自动将右侧向量扩展为24位，这意味着 `out[23:16]` 会被填充为零。因此，拼接运算需要小心处理不同位宽的信号，以避免意外的位宽扩展。

### 实践练习：拼接和分割

在一些实际应用中，可能需要将多个输入向量拼接起来，然后再将结果分割成多个输出向量。假设有六个 5 位输入向量 `a, b, c, d, e, f`，总共30位输入信号，同时有四个 8 位输出向量 `w, x, y, z`，总共32位输出信号。要求将输入向量拼接在一起，并在其后附加两个1位的常量 `1`。

<img src="{{ site.baseurl }}/docs/assets/QQ_1729499460744.png" alt="QQ_1729499460744" style="zoom:50%;" />

Verilog 代码实现如下：

```verilog
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );
  
 assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};  // 输入向量拼接，并加上两个1位常量
endmodule
```

在这个例子中，我们首先将六个5位输入向量 `a, b, c, d, e, f` 按顺序拼接在一起，构成一个30位的信号，然后附加上两个1位的常量 `2'b11`，使其总长度达到32位，刚好可以分配给四个8位的输出向量 `w, x, y, z`。

这种拼接和分割操作在信号处理、数据重排以及数据压缩和扩展等场景中非常常见。

---

# Vector Reversal

在 Verilog 中将一个8位输入向量 `in[7:0]` 的位顺序颠倒，也就是将 `in[0]` 赋给 `out[7]`，`in[1]` 赋给 `out[6]`，以此类推。这种操作虽然不能直接通过类似 `assign out[7:0] = in[0:7];` 的简单翻转实现，但可以通过连接运算符 `{}` 来简化代码。

### 问题分析

由于 Verilog 不支持直接颠倒位顺序的声明，需要通过具体的位映射来实现。常规的方式是通过多条赋值语句分别指定每个位的顺序：

```verilog
assign out[7] = in[0];
assign out[6] = in[1];
assign out[5] = in[2];
assign out[4] = in[3];
assign out[3] = in[4];
assign out[2] = in[5];
assign out[1] = in[6];
assign out[0] = in[7];
```

然而，这样的代码显得冗长且不够简洁。为了减少代码量，可以使用 Verilog 的**连接运算符** `{}` 将这些操作合并到一条赋值语句中。

<img src="{{ site.baseurl }}/docs/assets/QQ_1729499522136.png" alt="QQ_1729499522136" style="zoom:50%;" />

### 连接运算符的解决方案

通过连接运算符，我们可以将 `in` 各个位的反序组合起来，简化代码。以下是使用连接运算符的解决方案：

```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);

    // 使用连接运算符将位顺序颠倒
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};

endmodule
```

在这条 `assign` 语句中，`in[0]` 被分配给 `out[7]`，`in[1]` 分配给 `out[6]`，依此类推，实现了位顺序的反转。

### 更加灵活的位翻转

这种方法不仅适用于8位向量，还可以扩展到更长的向量。例如，对于一个16位或32位的向量，类似的位反转操作可以通过相同的连接运算符机制来实现，只需将位号按顺序调整即可。这种方式不仅高效，还能避免逐个位赋值的繁琐操作。

通过这种方法，我们用一条语句就完成了8位向量的位反转操作，代码简洁且易于维护。

---

# Replication Operator

在硬件设计中，连接运算符 `{}` 可以用来将多个向量拼接在一起，但当需要重复多个相同的向量时，手动编写冗长的代码显得繁琐。**复制运算符** `{num{vector}}` 可以用于简化这种操作，它允许将一个向量按照指定的次数进行复制并连接在一起。

### 复制运算符的使用

复制运算符 `{num{vector}}` 会将给定的 `vector` 复制 `num` 次，并将这些副本拼接起来。例如：

- `{5{1'b1}}` 会生成 `5'b11111`，即5个 `1` 连接在一起。
- `{2{a,b,c}}` 等价于 `{a,b,c,a,b,c}`，即将 `a, b, c` 的顺序重复两次。
- `{3'd5, {2{3'd6}}}` 则是将 `3'b110` 复制两次，与 `3'd5` 拼接，结果为 `9'b101_110_110`。

### 符号扩展（Sign Extension）

符号扩展是一种常见的操作，特别是在处理有符号数时。将一个较小的有符号数扩展到更大的位宽时，需要保留其符号位（最高有效位，MSB）。例如：

- 如果我们将 `4'b0101`（即+5）符号扩展为8位，应得到 `8'b00000101`（仍然是+5）。
- 如果将 `4'b1101`（即-3）符号扩展为8位，应得到 `8'b11111101`（仍然是-3）。

这可以通过将符号位（MSB）复制并连接到左侧来实现。

<img src="{{ site.baseurl }}/docs/assets/QQ_1729499677673.png" alt="QQ_1729499677673" style="zoom:50%;" />

### 实现符号扩展电路

在此任务中，我们需要将一个8位的有符号数扩展为32位，这需要将符号位 `in[7]` 复制24次，并拼接原来的8位数 `in`。可以通过以下代码实现：

```verilog
module top_module (
    input [7:0] in,          // 8位输入
    output [31:0] out        // 32位符号扩展的输出
);

    // 符号扩展：将符号位 in[7] 复制24次并连接到原来的8位数 in
    assign out = { {24{in[7]}}, in };

endmodule
```

### 详细解释

1. **符号位复制**：`{24{in[7]}}` 将 `in[7]`（符号位）复制24次，形成一个24位的向量。
2. **拼接原始数值**：然后我们将这个24位的符号扩展部分与原始的 `in` 拼接，得到一个完整的32位输出。
3. **最终结果**：该操作确保输入的符号位正确扩展，保持输入数的符号属性。

### 示例

- 对于输入 `in = 8'b01010101`（即+85），扩展后输出为 `32'b00000000_00000000_00000000_01010101`。
- 对于输入 `in = 8'b11110101`（即-11），扩展后输出为 `32'b11111111_11111111_11111111_11110101`。

通过这种方式，符号扩展操作得以简洁且有效地实现。

---

# More Replication

<img src="{{ site.baseurl }}/docs/assets/userlmn_bcfffcb25130fec9a2c8e637eb584594.png" alt="img" style="zoom:50%;" />

在这个问题中，目标是对五个1位信号 `a, b, c, d, e` 进行两两比较，计算所有 25 个一位比较的结果，并将这些结果存储在一个25位的输出向量中。如果两个信号相等，输出应为1。

### 问题分析

这意味着我们要构建一个包含所有信号之间的比较结果的25位向量。例如，比较 `a` 与 `a` 的结果存储在 `out[24]` 中，`a` 与 `b` 的比较结果存储在 `out[23]`，依此类推，直到 `e` 与 `e` 的比较结果存储在 `out[0]`。

### 关键运算符

1. **异或（XOR）操作**：在 Verilog 中，`^` 是异或运算符。如果两个信号相等，`~(a ^ b)` 将产生1，否则产生0。因此，通过计算两个信号的异或并取反，我们可以确定它们是否相等。

2. **复制运算符**：`{num{vector}}` 可以将输入向量复制多次，使得我们可以用很少的代码生成需要的比较结构。

### 解决方案

为了简化两两比较的操作，我们可以使用**复制运算符**和**连接运算符**。我们可以通过将输入信号 `a, b, c, d, e` 各自复制5次，形成25位的一个向量，与5次重复的信号拼接对比。如下图所示：

- **顶部向量**：`{{5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}}}`，这将生成一个25位的向量，其中 `a` 复制5次，`b` 复制5次，依此类推。
  
- **底部向量**：`{5{a, b, c, d, e}}`，将五个信号按顺序重复5次，也生成一个25位的向量。

通过对这两个向量执行按位异或操作并取反，我们可以得到所有的比较结果。下面是代码实现：

<img src="{{ site.baseurl }}/docs/assets/QQ_1729499915468.png" alt="QQ_1729499915468" style="zoom:50%;" />

### Verilog 实现

```verilog
module top_module (
    input a, b, c, d, e,
    output [24:0] out
);

    // 使用复制和连接运算符简化比较操作
    assign out = ~({{5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}}} ^ {5{a, b, c, d, e}});

endmodule
```

### 详细解释

1. **生成顶部向量**：`{{5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}}}` 将 `a, b, c, d, e` 各自重复5次，形成一个25位的向量，例如：

   ```
   {a, a, a, a, a, b, b, b, b, b, c, c, c, c, c, d, d, d, d, d, e, e, e, e, e}
   ```

2. **生成底部向量**：`{5{a, b, c, d, e}}` 将 `a, b, c, d, e` 拼接在一起，并将这个5位的序列重复5次，形成另一个25位的向量，例如：

   ```
   {a, b, c, d, e, a, b, c, d, e, a, b, c, d, e, a, b, c, d, e, a, b, c, d, e}
   ```

3. **比较操作**：通过对这两个向量执行按位异或操作并取反（`~`），我们得到所有信号之间的比较结果。`~(a ^ b)` 的值为1，表示 `a` 和 `b` 相等；为0则表示不相等。

### 示例输出

假设输入信号为 `a = 1, b = 0, c = 1, d = 0, e = 1`，则：

- 顶部向量为：`{11111, 00000, 11111, 00000, 11111}`。
- 底部向量为：`{10101, 10101, 10101, 10101, 10101}`。

比较结果（按位异或后取反）会生成一个 25 位的输出向量，表示所有信号的两两比较结果。

这种设计使用了 Verilog 的复制和连接运算符，大大简化了复杂的比较逻辑，实现了简洁、易读且高效的代码。
